Comunicação de processos a correr em host diferentes.

Host que envia, parte mensagens em segmentos enviando para o network layer.
Host que recebe remonta os segmentos.

Sender:

- passa uma application-layer message.
- determina os valores do segmento header.
- cria segmento.
- passa segmento ao IP.

Receiver:

- recebe.
- checka header.
- extrai message.
- desmultiplexa via socket.

### Multiplexing

![[Pasted image 20240106193449.png]]

Tanto para TCP/UDP um segmento tem 32 bits que inclui a porta de origem e de destino, header fields e a message.

Host usa **IP** e a **port** para encaminhar segmentos para os sockets corretos.

HTTP: 80 (TCP)
DNS: 53 (UDP)

## UDP


__Vantagens:__
- Simples.
- Tem menos delay que os outros protocolos mais simples.
- Tem o cabeçalho de segmento mais pequeno.
- Não há controlo de congestionamento, então pode ser que exista envio de dados muito rápido.

__Desvantagens:__
- Segmentos podem perder-se.
- Entrega pode ser feita fora de ordem.
- Não existe uma conexão entre emissor e recetor.


```c
struct addrinfo hints,*res;
hints.ai_family = AF_INET; // IPv4
hints.ai_socktype = SOCK_DGRAM; // UDP socket
hints.ai_flags = AI_PASSIVE|AI_NUMERICSERV;
getaddrinfo(NULL, PORT, &hints, &res);
MySocket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
bind(fd, res->ai_addr, res->ai_addrlen);
```

Identificados por um tuplo: __(dest IP address, dest port number)__.

Quando um host recebe um segmento UDP: Checka port e segmento correspondente ao socket.

![[Pasted image 20231201102417.png]]

Para a transferência ser ___confiável___ em UDP:
- adicionar reliability no application-layer.
- error recovery
- congestion control no application-leyer.
#### Checksum

Este campo serve para detetar erros no segmento transmitido.

Quando o campo é enviado o emissor guarda a soma de dois endereços IP no checksum.
Quando o campo é recebido o recetor faz a mesma conta para ver se dá igual.

Se der valores diferentes um erro é encontrado. Ignora-se o pacote. (Em TCP pedia-se de novo)

Pode mesmo assim não ser muito bom porque pode dar a mesma soma e não ser a mesma combinação.

## TCP

Identificado por um tuplo: (Source IP add, source port number, dest IP add, dest port number).

Server host pode receber mais do que um TCP sockets em simultâneo.


# RDT - Reliable Data Transfer (slides)

![[Pasted image 20231201103253.png]]

Unidirecional data.
Usa **Finite State Machines** (FSM) para especificar sender e receiver.  

### RDT 1.0
Canal é fiável.

```c
// Sender : espera por call above
rdt_send(data)
packet = make_pkt(data)
udt_send(packet)

// Receiver : espera por call below
rdt_rcv(packet)
extract(packet, data)
deliver_data(data)
```
### RDT 2.0
Aqui pode trocar-se bits num segmento. Para os identificar usa-se checksum.

- Recetor avisa emissor que recebeu pacote (ACK) ou que tinha erros (NAK).
- Se não foi bem recebido emissor reenvia.

Usa-se lógica __Stop and Wait__. 
Emissor envia pacote e fica à espera de reposta.

### RDT 2.1
Mesma lógica do anterior mas para evitar erros em que quando haja algo corrompido e se envie duas vezes a mesma informação existe um número de sequência para o cliente confirmar se é um segmento repetido ou não.

### RDT2.2
Só há ACK.

### RDT 3.0
Tem um _timeout_ já que os pacots podes nunca chegar. Se estiver à espera de uma resposta e não chegar a tempo a mensagem é reenviada. Nunca vai ser duplicada graças ao RDT2.1.

Ver slides das contas. página 26.

Pode acontecer que se dê um timeout e não seja suposto já que a resposta até ia chegar mas estava a demorar.
##### Sliding Window

![[0003-StopAndWait.svg]]

Eficiência de um Envio = (L / R) / ( (L / R) + RTT ) -> Muito ineficiente.
Solução:
Em vez de mandar um pacote e esperar por esse mandar no máximo N de uma vez e depois recebe-se todos juntos.

##### Go-Back-N (.leic) FORMULAS

O tamanho da janela tem de ser menor que a quantidade de número usados para numerar pacotes.

O emissor vai reenviando os pacotes a partir do primeiro que falhou.

##### Selective Repeat (.leic) FORMULAS

números de pacotes / 2 menor que tamanho de janela.

O emissor e recetor têm uma Sliding Window e estes apenas avançam quando o pacote mais antigo for ACK.






















