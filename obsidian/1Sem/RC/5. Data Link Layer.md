
É a camada que trata da transferência de dados entre um host e um router, ou entre dois routers pertencentes à mesma rede.

#### Framing e acesso a Links:
- encapsula datagram numa __trama__ - nome do pacote nesta camada, adicionadno cabeçalho e trailer.
- protocolo __MAC__ (Medium Access Control) para aceder ao meio compartilhado. Usam-se endereços MAC nos cabeçalhos das tramas para identificar origem e destino.

#### Deteção de erros:
- deteta erros causados por atenuação de sinal e ruído.
- recetor pode detetar presença de erros, sinalizando o remetente para reenviar ou descartando a trama.

#### Correção de erros:
- recetor pode corrigir erros de bits sem reenviar.

#### Controlo de fluxo:
- ajustar o ritmo entre nós adjacentes que enviam e recebem.

#### Links half-duplex e full-duplex:

___Half-duplex___ - É possível transmitir nos dois sentidos, mas num de cada vez.
___Full-duplex___ - Possível transmitir para os dois sentidos ao mesmo tempo.

## Terminologia

- **Nós** / **_Nodes_** - _hosts_ e _routers_ (ou seja, quem comunica);
- **Ligações** / **_Links_** - Canais de comunicação que conectam nós adjacentes ao longo do caminho de comunicação. Por exemplo, _links_ por fio, _links_ sem fio, LANs, etc.
- **Trama** / **_Frame_** - Pacote da camada de Ligação de Dados. Encapsula um datagrama.

# Endereços MAC

Data Link layer está implementada na ___NIC___ - interface de rede de cada host, que liga diretamente aos buses de hardware.

Cada placa de rede tem um endereço MAC associado. Como se fosse um identificador da placa do dispositivo.

Endereços MAC estão inbutidos na placa de rede enquanto que endereços IP podem ser alterados.

Para estes endereços:
- primeiros três bytes indicam o fabricante.
- últimos três bytes indicam o equipamento.

Endereço `FF:FF:FF:FF:FF:FF` é o _broadcast_.
Ao enviar um pacote para esse endereço, é enviado para todos os _hosts_ da rede local.

# Protocolo ARP - Address Resolution Protocol

Usa-se isto para o router saber a que MAC corresponde esse IP recebido.

1. O _router_ faz um `ARP Request`, ou seja, um _broadcast_, enviando para o endereço FF:FF:FF:FF:FF
    a pergunta: "Quem tem este endereço IP?"
2. O _host_ com o endereço IP responde com o seu endereço MAC.

De forma a não se estarem sempre a repetir estes pedidos, os _hosts_ guardam numa tabela (tabela ARP), o mapeamento entre endereço IP e endereço MAC - (`endereçoIP`, `endereçoMAC`, `TTL`).

# Deteção de Erros de Transmissão

Como detetar:

## Bit de Paridade

Acrescentar um bit no final dependendo:

- Se o número de bits fosse par, colocava-se um `0`;
- Se o número de bits fosse ímpar, colocava-se um `1`.

Não é uma forma muito boa pois não deteta um número par de erros.

## CRC - Cyclic Redundancy Check

![[Pasted image 20240108004203.png]]


# Colisões de Broadcast

Quando é feito um broadcast, este é partilhado por todos os membros da rede. Implica que pode haver colisões facilmente em que um nó pode receber um ou dois sinais ao mesmo tempo.

Protocolos ***Multiple Access Control*** - algoritmos distribuídos que determinam como é que os nós partilham um canal, ou seja, quando é que um dado nó pode transmitir.

Existem vários protocolos que implementam o acesso de formas diferentes:

##### Particionamento de canal fixo:
- Dividir canal em pedaços menores.

##### Alocação Dinâmica ("um de cada vez"):
- Os nós tomam a vez (nós com mais dados para enviar podem transmitir com mais frequência).
- _Poll_ / seleção.
- Passagem de um _token_.

##### Acesso Aleatório:
- Canal não é dividido, logo permite colisões.
- É possível recuperar das colisões.

### Particionamento do Canal fixo

Neste tipo de particionamento, o canal é fixo e é antes feita uma divisão por regras de ordenação dos _hosts_.
##### FDMA - Frequency Division Multiple Access

Espetro de canal é dividido em faixas de frequência. 
A cada estação é atribuída uma faixa de frequência fixa,
mas o tempo de transmissão não utilizado não é aproveitado.

##### TDMA - Time Division Multiple Access

Acesso ao canal feito em rondas.
É atribuído a cada _host_ uma fatia temporal em cada ronda.
Tempo não utilizado não aproveitado.

##### CDMA - Code Division Multiple Access

Cada utilizador tem acesso à frequência completa durante todo o tempo.
Usa-se diferentes códigos para distinguir diferentes utilizadores.

### Alocação Dinâmica

##### Poll / Select

Computador central controla atividade dos outros.

##### Token Passing

Token que dá a permissão de transmissão é passado entre hosts.
Quando um host acaba de transmitir, passa o token para outro host.

Esta medida não é ideal se existir muito tráfego, pois existe dependência que os _hosts_ transmitam as mensagens.

### Acesso Aleatório

Neste não existe qualquer divisão de canal nem de corrdenação.
Quando existe um pacote para enviar, envia-o à _rate_ máxima.

Protocolos servem para identificar colisões e como recuperar delas:

##### ALOHA

Não tem sincronização.
Existe sobreposição se duas ou mais tramas se sobreposerem, sendo programada uma retransmissão para um instante futuro aleatório.

##### Slotted ALOHA

Há sincronização.
Igual mas o tempo é dividido em _slots_ temporais do mesmo tamanho.
Nós só podem começar a transmitir no início de um _slot_.
Se dois ou mais nós começarem a transmitir no mesmo _slot_ existe colisão e aí o nó retransmite o frame em cada sub slot com propabilidade p até haver sucesso.

Prós:
- Cada nó ativo transmite continuamente a máxima rate.
- altamente descentralizado: apenas as durações do slot precisam de estar sincronizadas com cada nó.
- Simples.

Cons:
- Colisões, slots desperdiçados.
- Slots parados.
- Nós precisam de conseguir detetar a clisão antes de transmitir esse pacote.
- sincronização de relógio.

![[Pasted image 20240108171503.png]]


##### CSMA - Carrier Sense Multiple Access

Objetivo de não causar interrupções:
- Se o canal estiver calado, transmite a trama inteira.
- Se o canal estiver ocupado, adia a transmissão.

Mesmo assim podem existir colisões devido ao tempo de propagação o que leva a que a transmissão de um pacote tenha que ser descartada.

##### CSMA/CD - CSMA com Deteção de Colisões

Consegue detetar colisões mais rapidamente.
Reduz ocupação de canal que as transmissões são imediatamente abortadas quando detetada uma colisão.

## Resumo dos protocolos

**Particionamento de canal fixo**:

- Eficientes com uma carga alta e constante de todos os nós;
- Ineficientes em cargas baixas ou desequilibradas.

**Alocação dinâmica ("um de cada vez")**:

- Compartilham o canal de forma eficiente e justa em cargas altas;
- Baixa carga: ineficiente, pois os nós ativos precisam de esperar pelos nós com pouca ou sem atividade para "passarem a vez";

**Acesso Aleatório**:

- Eficientes em carga baixa porque apenas um único nó pode utilizar o canal num dado momento;
- Carga alta: sobrecarga de colisão.


# IEEE 802.3 - Ethernet

## Topologias de Rede

### Bus

Cabo principal partilhado por vários computadores. Todos os host ouvem todos os hosts e está muito sujeito a colisões.

### Estrela

Em vez de ser um cabo principal é um _switch_.
Não existe colisões.

## Frames de Rede

Na camada de Ligação de Dados (layer 2), pacotes são chamados de _Frames / Tramas_ e têm o formato:

![[Pasted image 20240108172521.png]]

- Preâmbulo - Usado para sincronizar as _clock rates_ dos emissor e recetor;
- Endereços - Endereços MAC do emissor e do recetor;
- Tipo - Indica o protocolo da camada superior (Ex. IP);
- Data - Dados a serem transmitidos;
- CRC - _Checks_ para correção de erros.

É nesta frame que são guardados os IP datagrams.

### Problemas em Algoritmos de comunicação

- ___Connectionless___ - Não existe conexão entre sender e receiver NICs.
- ___Unreliable___ - Receiving NICs não mandam ACKs ou NACKs para o sending NIC. Pode levar a datagrams perdidos e a lacunas posteriormente . Se se estiver a usar TCP as lacunas são preenchidas.


## Algoritmo CSMA/CD

1. A NIC recebe o datagram da camada de rede -> cria uma trama.
2. Se o __canal estiver livre__ (idle) (espera-se 96 tempos de bit), começa a transmissão das tramas. Se __estiver ocupado__ espera que esteja idle e aí transmite.
3. Se a NIC transmitir a trama inteira sem detetar outra transmissão -> **sucesso**;
4. Se a NIC detetar outra transmissão enquanto transmite -> colisão -> aborta e manda sinal de interferência, avisando todos que houve colisão.
6. Depois de abortar, a NIC entra em retrocesso exponencial -> Depois da m-ésima colisão, a NIC escolhe um número K aleatoriamente em {0,1,2,…,2m−1}; A NIC aguarda K×512K tempos de bit de transmissão; Depois, retorna ao Passo 2.

Este algoritmo pretende através da detenção de colisões minimizar as próximas já que todos vão ser avisados que houve uma colisão e ordenados a parar, restabelecendo a ordem.

Contudo com muito tráfego continuam a existir muitas colisões.

## Hubs

Bits que vêm num link saem em todos os outros links da mesma rate.
Todos os nós conectados a uma hub podem colidir com outros.
Sem frame buffering.
Sem CSMA/CD no hub: Os hosts é que detetam as colisões.

## Switches

Dispositivo do Link Layer.

Switches ao contrário de hubs quando um hostA fala com um hostB, o switch aprende a sua localização e fica a saber que o hostA está na porta x.
Pode haver várias ligações em simultâneo o que reduz as colisões.

Para mapear isso existe a ___Switching Table___ - sempre que houver uma nova transmissão o switch constrói uma switching tabçe onde regista um mapeamento de quem transmitiu e onde.

Entradas guardadas do tipo `(Endereço MAC, interface do switch, TTL)`onde TTL é o tempo até esta entrada não ser mais válida.

Sempre que o _switch_ quer enviar algo para um _host_, verifica primeiro se existe uma entrada válida na tabela com o endereço de destino:

- Se estiver, envia para a interface associada.
- Se não estiver, faz **_flooding_** - a mensagem é repetida em todas as interfaces (à exceção da que enviou a trama) - neste caso, funciona como um _hub_.

Podemos ligar switches a switches.

#### Falta de redundância

exemplo no .leic

A redundância precisa de estar desligada logicamente, a ligação f
física está desligada mas o switch desativa a porta até ser necessária.

Para descobrir quais caminhos se devem usar e que interfaces desligar usa-se o algoritmo ___STP___ (Spanning Tree Protocol

#### STP - Spanning Tree Protocol

- **Bridge ID** - Cada _switch_ é identificado por um endereço constituído por 2 bytes que representam a prioridade e 6 bytes que são o endereço MAC do _switch_. Por exemplo, `8000.AA:BB:CC:DD:EE:FF` é o ID do _switch_ com endereço MAC `AA:BB:CC:DD:EE:FF` e com uma prioridade de 0x8000.
- **Root Bridge** - _Switch_ que é o nó inicial da árvore. É o _switch_ com o menor _Bridge ID_ (ou seja, a prioridade serve para "forçar" um _switch_ a ser a _root bridge_ e os seus sucessores).
- **Root Port** - Porta que, num dado _switch_, é responsável pelo envio/receção de frames para/da _root bridge_ - são o caminho em direção ao _root bridge_ (daí **Root Port**, "porta para o _root_").
- **Designated Bridge** - _Switch_ que, num dado segmento de rede, é responsável por enviar/receber as tramas da rede para/da _root bridge_.
- **Designated Port** - Porta da _Designated Bridge_ por onde passa o tráfego para/da _root bridge_.

Vale notar que:

- **Root Port** não está relacionado com a _root bridge_.
- Para um dado segmento de rede, onde podem estar computadores, impressoras, etc., estes enviam tráfego para o _switch_, sendo essa porta a **Designated Port**. O _switch_ por sua vez, envia o tráfego pela **Root Port**, que aponta na direção da _root bridge_. Ou seja, o tráfego "flui" de **Designated Ports** para **Root Ports**.
- Cada rede terá uma _root bridge_, cada _switch_ (exceto a _root bridge_, que não tem nenhuma) terá apenas uma **Root Port**, cada segmento de rede terá apenas uma **Designated Port** e as restantes portas ficarão inativas.
- Cada _switch_ tem um custo para chegar à _root bridge_, que é igual à soma dos custos de todas as portas que transmitem em direção à _root bridge_ (**Root Ports**).
- As restantes portas que não são usadas são as portas que são desativadas, ou seja, a árvore é definida pelas portas não bloqueadas.

##### BDPUs - Bridge Protocol Data Units

Switches enviam isto uns para os outros para comunicarem:

```
(ID do Root Bridge, Custo até Root Bridge, ID de quem enviou a BPDU, ID da porta que originou a BPDU)
```


Quando um _switch_ é ligado, o algoritmo STP é usado para identificar a _root bridge_, sendo enviadas BPDUs com o BridgeID do novo _switch_.  
Este, até receber BPDUs, assume ser a _root bridge_. Porém, quando receber uma BPDU, este verá o BridgeID da _root bridge_:

- Se esse BridgeID for menor que o dele, o _switch_ aceita que esse BridgeID é a _root bridge_ e deixa de assumir ser ele a _root bridge_;
- Se esse BridgeID for maior que o dele, então ele continua a assumir ser a _root bridge_. Quando os outros _switches_ receberem o seu BridgeID, estes verão que é menor que os deles, então atualizarão a sua _root bridge_.


Algoritmo explicado no .leic.

Quando existir uma mudança na topologia de rede (por ex., um _switch_ é removido ou uma nova _root bridge_ é introduzida), poderá:

- existir uma perda temporária de conectividade, pois uma porta anteriormente bloqueada e que deve ser ativa pode ainda não ter passado a ativa;
- existir ciclos temporários, pois uma porta anteriormente ativa e que deve ser bloqueada ainda não ter passado a bloqueada.

Para minimizar a probabilidade de ciclos temporários, os _switches_ devem esperar algum tempo antes de trocarem uma porta de um estado bloqueado para um estado ativo.

## VLANs

As VLANs têm algumas vantagens:

- dividem a rede em partes, reduzindo o domínio de _broadcast_ o que, consequentemente, aumenta a _bandwidth_ pois as mensagens não são enviadas para portas desnecessárias;
- adicionam segurança, pois _hosts_ em diferentes VLANs não conseguem comunicar entre si diretamente;

Para as VLANs poderem comunicar entre si, existem mecanismos de _routing_ (pelos _routers_).

# Redes Wireless

**Handoff** - Se um _host_ estiver em movimento e passar de um AP para outro, a comunicação consegue continuar, fazendo com o que o 1º AP passe a conexão (faça _handover_) para o outro AP.

Apesar de ter várias vantagens, como:

- Permitir comunicação em movimento;
- Permitir comunicação em sítios que é complicado ter rede cablada;
- Permitir fazer _broadcasting_;
- Ser mais conveniente para os utilizadores;
- Ter menos cabos e ser esteticamente mais bonito;
- ...

Estes sistemas têm várias desvantagens que influenciam a qualidade do sinal, como:

- Ambiente menos controlado, sendo mais subjetivo a interferências e ruído (frequências estandardizadas, usadas por outros _hosts_, bem como ruído de motores, microondas, ...);
- Velocidades de transmissão menores;
- Propagação em diferentes caminhos, chegando ao destino em _timestamps_ diferentes.

Para além desses problemas, existe um mais grave: **o problema do terminal escondido**.

Como resolver problemas gerados:

### CSMA/CA - ### Carrier sense multiple access (with collision avoidance)

Pareciso ao básico CSMA mas para além de esperar que o canal fique livre, ainda espera um tempo aleatório depois do canal se libretar.

Depois de uma transmissão, o AP devolve um ACK para confirmar o sucesso da transmissão. Isto ajuda a resolver o problema do terminal escondido - porém não o resolve na totalidade pois podem haver tempos em que o início das transmissões coincide.

Para resolver isto, surgiu a variante com RTS-CTS.

### ### CSMA/CA com RTS-CTS (Request-To-Send e Clear-To-Send)

EM vez de começar a sua transmissão primeiro faz um pedido de reserva do canal.

Desta forma, o AP reserva-lhe o canal e dá-lhe um OK, fazendo _broadcast_ de um CTS com a informação de quem vai emitir.  
Assim, um outro _host_ que não ouça o emissor, ouvirá certamente o AP e não irá transmitir.

Se tiver existido uma colisão nesse pedido, esta terá um impacto muito reduzido, pois foi apenas transmitido um pacote.

Muitos exemplos no .leic.





 

















